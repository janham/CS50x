# Memory

## 16進数

メモリのアドレスは16進法を使用している

01 02 ... 09 10 1a 1b 1c 1d 1e 1f

- RGB

    カラーコードの#00000や#FFFFFFは16進数が使われている

## Address

### Cでのメモリーの参照

```c
int main(void)
{
    int n = 50;
    printf("%p\n", *&n);
}
```

- `&` どのアドレスにあるかを示す
- `*` ポインタが指しているアドレスに移動する

上記コードだとn のアドレスに 「移動」 する *&n を出力すると、アドレス n の値である 50 が出力される。

### ポインタについて

アドレスを格納する変数はポインタと呼ばれ `*` 演算子を使用して、ポインタにしたい変数を宣言する

また、Cにおいては `string` という型はもともと存在しておらず

`char *` をもって文字列の型を定義することができる(詳しくはポインタの仕組みと関連)

### ポインタ演算について

```c
int main(void)
{
    char *s = "HI!";
    printf("%c\n", *s);// または printf("%c\n", s[0]);
    printf("%c\n", *(s+1));
    printf("%c\n", *(s+2));
}
```

`*s` *でsに格納されているアドレスに、*(s+1) は1バイト上位のアドレス、つまり次の文字を持つメモリ内の場所に移動する

- **セグメンテーション違反**

(s+10000) のように、メモリ内のアクセスするべきではないアドレスにアクセスすることもできるが、プログラムが不要なセグメントのメモリにアクセスして結果クラッシュすることになるので注意

メモリを使用し終えた後はメモリの開放を行う

`valgrind` を使用しメモリ関連のデバッグをする

## 比較とコピーの際のメモリ参照

```c
int main(void)
{
    char *s = get_string("s: ");
    char *t = get_string("t: ");

    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```

sとtの入力値が同じでもdifferentになってしまうのは最初の時点の文字のポインタの箇所を返しているため(tとsのメモリ参照箇所はもともと異なるためそれによりdifferentとなる)

`malloc` は、 (他の値を格納するために使用されていない) メモリ内のバイト数を割り当て、使用する分だけのバイト数を渡すためメモリの確保に使用する。

コンピュータのメモリが不足している場合、 `malloc` は NULLを返す。下記コードの場合t が NULL ならばメモリ領域の使用を終了する。

```c
int main(void)
{
    char *s = get_string("s: ");

    char *t = malloc(strlen(s) + 1);
    if (t == NULL)
    {
        return 1;
    }

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    if (strlen(t) > 0)
    {
        t[0] = toupper(t[0]);
    }

    printf("s: %s\n", s);
    printf("t: %s\n", t);

    free(t);
}
```

`free` 関数を呼び出すことでメモリのチャンクは終了となる。

ループの代わりにCの文字列ライブラリ関数 `strcpy` を使用してもOK

## valgrind

`valgrind` はプログラムを実行し、メモリリークが発生していないか解放せずに割り当てたメモリがあるかどうかを確認するために使用できるコマンドラインツール。

先程のコードで `free` を使用せずメモリ解放を行わない場合に使うとエラーを吐いてくれる

```c
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;

    y = x;

    *y = 13;
}
```

上記の場合yのメモリの値が未知数になるのでセグメンテーション違反が出てしまう。

## Swap

2つの整数を入れ替えるプログラムを組むにあたりメモリレイアウトについて学ぶ

![memory_layout.png](./memory_layout.png)

### heap

ヒープセクションは、malloc がプログラムで使用するための空きメモリを取得できる空の領域でmalloc を呼び出すと、トップダウンでメモリの割り当てを開始する。

### Stack

呼び出されたプログラム内の関数によって使用され、上に向かって成長する。

たとえば、main 関数はstackの一番下にあり、ローカル変数 x と y を持っているとする。swap関数は、呼び出されると main の上に独自のメモリ領域を持つこととなり、ローカル変数の a ,b および tmp を持つことになる。

```c
void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

`swap` が終了するとメモリ解放がされるため、aとbの変更を保持するためswap内で変更後の値を元のa,bそれぞれのアドレスに移す必要がある。移さないとswapのメモリ開放とともに変更した挙動もなかったことになってしまう。